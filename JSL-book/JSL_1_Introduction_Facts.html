<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<br>
<h1> как передаются строки, по ссылки или по значению?</h1>
* types of data: Number, string, boolean, object( class(Data), RegExp - regular expression), regular, array, function </br>
* Стандарт языка ECMA br </br>
* Пример работы document.write() - С помощью js генерирует html, да и любой код и записывает его в фаил </br>
<script>
    var fact = 1;
    for(i = 1; i < 10; i++) {
        fact = fact*i;
        document.write(i + "! = " + fact + "<br>");
    }
</script>
* "fn + f12" в консоле можно писать/проверять однострочные запросы.</br>
* JS поддерживает юникод, но русский язык можнет быть только в комментариях или строковых литерах.</br>
* JS чувсвителен к регистру</br>
* Вообще точку с запятой писать не обязательно, но надо. Когда программа компилится, автоматически в конце каждой строки
ставится ';', и дальше исполняется, как одна большая строка. Из-за этого могут быть проблемы, например: </br>
<p style="font-style:italic">
return </br>
true; </br>
</p>
перейдёт в
<p style="font-style:italic">
return; </br>
true; </br>
</p>
хотя смысл был </br> <p style="font-style:italic"> return true; </br> </p>
* Комментарии, как в c++ /*...*/ , // </br>
* Переменные могут начинаться с английских букв, знаков '$', '_'. </br>
* Не начинаются с цифр, чтобы инторпритатору числа было проще отличать </br>

<h2> Численный тип данных</h2>

* Целые числа в диапазоне от –9007199254740992 (–2^53) до 9007199254740992 (2^53)</br>
* Шестизначные числа начинаются с Ox, например Oxff^ в десятиричной это 255</br>
* В восьмеричной с 0, 0377 в восьмеричной - это 3 * 64 + 7 * 8 + 7 = 255 по основанию 10</br>
* Десятичные числа через точку.</br>
* Експоненциальная запись десятичного числа: 6.02e23 = 6.02 * 10^23;</br>
<p style="font-style:italic"> Math, Math.sin(..) - </p> Многие функции/операции с числовым типом хранятся в библиотеке Math. </br>
Подробнее об этом в самой библиотеке. </br>
* При делении на ноль переменная числового типа может принять значение NaN, при достижении числа, больше чем максимального, </br>
значение будет Infinity. NaN = Not a number, проверка ".isNaN()". Вторая проверка "isFinite()" </br>
* Number.MAX_VALUE - Максимальное представимое число </br>
* Number.MIN_VALUE Наименьшее (ближайшее к нулю) представимое значение </br>
<script>
    document.write(Number.MAX_VALUE + "</br>");
    document.write(Number.MIN_VALUE + "</br>");
</script>
<h2> Строковой тип данных </h2>
* Нет char, только string (если надо, то одиночной длины)</br>
* \n для переноса строки в строковых литералах, а \' - одинарная ковычка</br>
* \xXX Символ Latin1, заданный двумя шестнадцатеричными цифрами XX</br>
* \uxXXXX Unicodeсимвол, заданный четырьмя шестнадцатеричными цифрами XXXX</br>
* \XXX Символ из набора Latin1, заданный тремя восьмеричными цифрами XXX, с кодом в диапазоне от 1 до 377. Не поддержи</br>
* .length - длина строки</br>
* .charAt(s.length – 1) - последний элемент строки</br>
* .substring(1,4) - вывод с 1 по 3 сивол включительно</br>
* concat(string1, string2, ..., stringN) - соединение строк с пробелами(то есть будет пробел между соединёнными строками)</br>
* .split('разделитель') - разделитель строки на массив подстрок по указанному разделителю</br>
* Есть ещё второй необязтальный аргумент, который равен максимальному кол-ву элементов в массиве</br>
* .toLowerCase() - преобразовывает все буквы в строке к нижнему регистру</br>
* .toUpperCase() -  преобразовывает все буквы в строке к верхнему регистру</br>
* substring(indexA, indexB) - возвращает часть строки начиная с позиции indexA, но не включая indexB</br>
* slice( indexA, indexB ) - возвращает часть строки начиная с позиции indexA, но не включая indexB</br>
* substr(indexA, length) - возвращает часть строки начиная с позиции indexA, в количестве length</br>
* replace(regexp, newSubString|function)  - возвращает новую строку после замен, указанных в regexp, или функцию,</br>
  которая ее возвращает. Регулярные выражения - RegExp, мы с вами рассмотрим подробно в третьем модуле курса.</br>
* Различие между substring и slice – в том, как они работают с отрицательными и выходящими за границу строки аргументами:
* substring -2 - > 0, slice -2 -> length - 2
* .indexOf('a'); - первый индекс элемента 'a' в строке</br>
* lastIndexOf -//-
<script>
    s = "0abcdefgh";
    sub = s.substring(1,4);
    //alert(sub);
</script>
<h2> Преобразование числа в строку </br> </h2>
* number + "" </br>
* String(number) </br>
* number.toString() - один необязательный аргумент - система счисления</br>
Пример: var n = 17; hex_string = "0x" + n.toString(16); </br>
* .toFixed(k), k - кол-во знаков после запятой (тоже число преобразует в строку)</br>
* .toExponential(k), так же, только экспоненциальная форма.</br>
<h2> Преобразование строки в число </br> </h2>
* number = string - 0;</br>
* Number(string)</br>
* parseInt(string) - парсит строку и выдаёь оттуда целове значение "3 слепых мыши" -> 3, "3.14 - корень уравнения" -> 3 </br>
Возможен ещё второй аргумент - система счисления ответа</br>
* parseFloat(string) - -//- "3.14 gggg" -> 3.14. Если числе много, то выдаст самое первое.</br>
* Методы не всегда работают, выводят NaN, если не получается</br>
<h2> Лошический тип данных </h2>
* Если true, false в численном смысле используются, то автоматически преобразуются в 1 и 0</br>
* 0, NaN - false; любой другое число - true</br>
* Если строка не пустая, то преобразуется в true, наобарот в false</br>
* Явное преобразование в тип Boolean: Boolean(x)</br>


















<h2> Функции </h2>
<script>
    function move(a) {
        alert(a);
    }
    var g = "string";
    //move(g);
</script>
* Пример задания функционального литерала var square = function(x) { return x*x; } </br>
* if(!a) a = []; Если массив не опредлен или получено значение 0 - создать пустой массиив</br>
* замена этой записи: a = a || [];</br>
* arguments - ссылка на объект со входными аргументами</br>
* имеет свойство length - кол-во входных данных. Число фактических аргументов. То есть сколькопередали</br>
* Arguments - объект, нечто вроде массива, позволяющего ищвлекать переданные функции значения по номер,а не по имени</br>
* Есть свойство callee</br>
* Имеет место записть arguments[0] ...</br>
* Первый входной аргумент и arguments[0]  - это одно и тоже => Если изменить один, то и другой изменится</br>
* arguments - это не зарезервированное слово, его не надо использовать, кроме как в данном контексте</br>
* Свойство callee ссылающееся на исполняемую в данный момент функцию</br>
<pre>function f(var x){</pre>
<pre>   if(x <= 1)</pre>
<pre>       return 1;</pre>
<pre>   return x * arguments.callee(x - 1);</pre>
<pre>}</pre>
* Вместо того, чтобы передавать много аргументов, можно создать объект с хорошо названными свойствами, например from, to, index</br>
* И передать в функцию obj, такой что obj.from = .., object.to = ..</br>
* У самой функции тоже есть свойство length. f.length - выдаёт кол-во заявленно нужных аргументов, например function f(x,y) - выдаст 2</br>
* То с каким кол-вом аргументов функция была создана</br>
*
* Функция с именем check() получающая массив аргументов от другой функции, и проверяет передано функции столько аргументов, сколько она ожидает.</br></br>
<pre>function check(args){</pre>
<pre>   var actual = args.length;</pre>
<pre>   var expected = args.callee.length;</pre>
<pre>   if(actual != expected){</pre>
<pre>       throw new Error("Ожидается число аргументов: " + expected)</pre>
<pre>   }</pre>
<pre>}</pre>
<pre></pre>
* Определение собсвенных свойств функции</br>
* Функция, которая должны каждый раз возвращать новый индекс, которого не было раньше.</br>
* Функции иниализируется раньше, поэтому мы реально можем писать такое</br>
<pre>uniqueInteger.counter = 0;</pre>
<pre>function uniqueInteger() {</pre>
<pre>   return uniqueInteger.counter++;</pre>
<pre>}</pre>
* Методы apply и call</br>
* Позволяются вызвать функцию, будто она метод чьего-то объекта.</br>
* Первый аргумент - это объект, на который можно будет сослаться this</br>
<pre>f.call(o,1,2) </pre>
<pre>   <=></pre>
<pre>o.m = f</pre>
<pre>o.m(1,2)</pre>
<pre>delete o.m</pre>
* метод apply такой же, просто вместо перечесления аргументов, передаётся массив. </br>
*</br>
* О видимости</br>
* Это означает, что вложенная функция обладает возможностью доступа ко всем аргументам и локальным переменным объемлющей функции.</br>
* Как лучше вызвать сторонний код, да бы не произошло конфликта с глобальными переменными, ведь в этом коде есть свои имена.</br>
* Создаём функцию - объект, и тогда все имена из импортированного кода будет пренадлежать function, проблем не будет</br>
<pre>(function( ) { // Это безымянная функция.</pre>
<pre>// Здесь располагается импортируемый программный код. Любые</pre>
<pre>// объявленные переменные станут свойствами объекта вызова, тем самым</pre>
<pre>// исключается вероятность конфликтов с глобальным пространством имен.</pre>
<pre>})();</pre>
*</br>
* Функции в JavaScript представляют собой комбинацию исполняемого программного кода и области видимости, в которой этот код исполняется. Такая</br>
* комбинация программного кода и области видимости в литературе по компьютерной тематике называется замыканием (closure).</br>
* Сложные пример.</br>
*</br>

<script>/*
    uniqueID = (function() { // Значение сохраняется в объекте вызова функции
        var id = 0; // Это частная переменная, сохраняющая свое
        // значение между вызовами функции
        // Внешняя функция возвращает вложенную функцию, которая имеет доступ
        // к этому значению. Эта вложенная функция сохраняется
        // в переменной uniqueID выше.
        return function() { return id++; }; // Вернуть и увеличить
    })();

    var a = [];
    for(var i = 0; i < 10; i++) {
        alert("uid:"+ uniqueID());
    }
*/
</script>

<script>
    // Эта функция добавляет методы доступа к свойству объекта "o"
    // с заданными именами. Методы получают имена get<name>
    // и set<name>. Если дополнительно предоставляется
    // функция проверки, метод записи будет использовать ее
    // для проверки значения перед сохранением. Если функция проверки
    // возвращает false, метод записи генерирует исключение.
    //
    // Необычность такого подхода заключается в том, что значение
    // свойства, доступного методам, сохраняется не в виде свойства
    // объекта "o", а в виде локальной переменной этой функции.
    // Кроме того, методы доступа определены локально, в этой функции
    // и обеспечивают доступ к этой локальной переменной.
    // Примечательно, что значение доступно только для этих двух методов
    // и не может быть установлено или изменено иначе, как методом записи.
    function makeProperty(o, name, predicate) {
        var value; // This is the property value
        // Метод чтения просто возвращает значение.
        o["get" + name] = function() { return value; };
        // Метод записи сохраняет значение или генерирует исключение,
        // если функция проверки отвергает это значение.
        o["set" + name] = function(v) {
            if (predicate && !predicate(v))
                throw "set" + name + ": неверное значение " + v;
        else
            value = v;
        };
    }
    // Следующий фрагмент демонстрирует работу метода makeProperty().
    var o = {}; // Пустой объект
    // Добавить методы доступа к свойству с именами getName() и setName()
    // Обеспечить допустимость только строковых значений
    makeProperty(o, "Name", function(x) { return typeof x == "string"; });
    o.setName("Frank"); // Установить значение свойства
    //alert(o.getName( )); // Получить значение свойства
    //o.setName(0); // Попытаться установить значение ошибочного типа
</script>

* Возможно создание функций с помощью конструктора Function()</br>
<pre>   var f = new Function("x", "y", "return x*y;");</pre>
* Означает примерно это
<pre>   function f(x, y) { return x*y; }</pre>

* когда функция создается с помощью конструктора Function(), не учитывается текущая лексическая область видимости –</br>
* функции, созданные таким способом, всегда компилируются как функции верхнего уровня, что наглядно демонстрируется</br>
* в следующем фрагменте: </br>

<script>
    var y = "глобальная";
    function constructFunction() {
        var y = "локальная";
        return new Function("return y"); // Не сохраняет локальный контекст!
    }
    // Следующая строка выведет слово "глобальная", потому что функция,
    // созданная конструктором Function(), не использует локальный контекст.
    // Если функция была определена как литерал,
    // эта строка вывела бы слово "локальная".
    //alert(constructFunction()()); // Выводит слово "глобальная"
</script>








<h2> Объекты </h2>
<script>
    var ob = new Object();
    ob.a = 2.3;
    ob.b = 2.4;
    //alert(ob.a + ob.b);
</script>
* var point = { x:2.3, y:1.2 }; Можно так задавать объекты, свойство-значение </br>
* объектные литералы могут быть вложенными </br>
<script>
    var point = {
        Low:{x:1,y:2},
        High:{x:1,y:3}
    }
    document.write("* " + (point.Low.x + point.High.x) + " - ответ 2 в примере работы с инициализацией объекта </br>");
    document.write(point.toString() + " - преобразованный объект в строку <br>")
</script>
<!- Ещё один способ задавать новый объект-->
<script>
    function Person(a, b) {
        this.a = a;
        this.b = b;
    }
    var kill = new Person(3,4);
    kill.who = function (name) {
        console.log("i have killed "+ name);
    }
    kill.who("platon");
    for(var checker in kill){
        console.log(checker.toString() + " has value:" + kill[checker]);
    }
</script>
* ОБЪЕКТ  для удаления свойства объекта delete Object.property; </br>
* Действия над объектами - ссылочные, то есть передавая их в функции и изменяя внутри, они будут меняться.</br>
* Сами ссылки передаются по значению, то есть если мы передаём ссылку и пытаемся изменить её внутри функции, то ничего не выйдет
  Можно менять именно то, на что она ссылается.</br>
<p><img src="media/По%20ссылке%20или%20значению.png" width="600" height="170"></p>
* Перечесление свойств объекта for (var name in obj) names +=name + '\n';</br>
* if("x" in o) o.x = 1; - Проверка на существоание свойств. if(x !== undefined)o.x = 1; Или так</br>
* У каждого объекта в js есть свойство констурктор
<pre>var d = new Date( );</pre>
<pre>d.constructor == Date; // Равно true</pre>
<h3> Свойства и методы Object</h3>
* constructor ^
* toString(). В целом не очень информаьивно, но когда с массивом, то строка из элементов массива, с функцией - её код
* toLocalString - Изначально тоже, что и первый, но подкалссы могут его переопределять для себя, так у Array, Date, Number
* hasOwnProperty возвращает true, если для объекта определено не унаследованное свойство с именем, указанным в аргументе
<pre>var o ={};</pre>
<pre>o.hasOwnProperty("undef"); </pre>
<pre>Math.hasOwnProperty("cos");</pre>
<script>
    var o = {};
    //alert(o.hasOwnProperty("undef"));
    o.a = 2;
    //alert(o.hasOwnProperty("a"));
</script>
* propertyIsEnumerable() - true, если есть такое свойство в обхекте, и оно может быть пересчитано в for/in</br>









<h2> Массивы </h2>
* может содержаться абсолютно любой тип данных</br>
* У элементов не обязательно одинаковый тип, так как js не типозированный</br>
* Пример создания var a = new Array(); Так у него может быть любое кол-во элементов. Это через конструктор</br>
* Если же передать число в виде аргумента, то кол-во допустимых элментов станет конечным</br>
* Или так var a = new Array(1.2, "JavaScript", true, { x:1, y:3 });</br>
* var a = new Array(10); - единственный числовой элемент - длина массива</br>
* Индексы до 2^31 - 1 </br>
<script>
    var a = new Array();
    a[1] = 'g';
    a[0] = 2; // Это работает
    var my;
</script>
* Как таковых многомерных массивов нет, однако существуют вложенные массивы, наприменр var matrix = [[1,2,3], [4,5,6], [7,8,9]];</br>
* var sparseArray = [1,,,,5]; Вот такой массив содержит 5 элементов, 3 из которых не определены</br>
* Добавление: .push()</br>
* length() - длина массива </br>
* length может укорачивать и удлинять массив, стирая и добавляю неивестные элементы в него </br>
* unshift() - Добавление элемента в начало массива</br>
* pop - удалить с конца и уменьшить длину на 1</br>
* shift - удалить сначала и уменьшить длину на 1, сдвинув все элементы.</br>
* delete array[4] - просто очистка ячейки до значнеие undefined</br>
* Array.join() - превращает все элементы массива в строки, объединяет их и возвращает получившуюся строку.</br>
* Array.reverse() - меняет порядок следования элементов в массиве на обратный и возвращает уже переупорядоченный массив.</br>
* Array.sort() - сортирует элементы в исходном массиве и возвращает отсортированный массив. Неопределенные элементы в конец масиива</br>
* Аргумент функции sort - функция сравнения.
<pre>var a = [33, 4, 1111,222]; </pre>
<pre>a.sort(); // Алфавитный порядок: 1111, 222, 33, 4</pre>
<pre>a.sort(function(a,b) { // Числовой порядок: 4, 33, 222, 1111</pre>
<pre>                       return a-b; // Возвращает значение < 0, 0, или > 0</pre>
<pre>       });// в зависимости от порядка сортировки a и b</pre>
* Array.slice() - возвращает подмассив из массив</br>
* Array.splice() - универсальная функция, которая позволяет удалять элементы из массива и вставлять новые.</br>
  1 аргумент - позиция элемента, с которого начинается действие метода</br>
  2 аргумент - количество удаляемых элементов, начиная со стартовой позиции, указанной в предыдущем аргументе.
  (Если второе значение не указано, будут удалены все элементы, начиная с первого аргумента).</br>
  3 аргумент и последующие (любое количество) - элементы массива, которые будут добавлены начиная с позиции, указанной в первом аргументе.</br>
<script>
    var myArray = ["Иванов", "Петров", "Сидоров", "Кузнецов"];
    myArray.splice(1,2, 3, "lol", true);
    console.log(myArray.join());
    var my = "hello";
</script>
* Array.join() - Все элементы в строки и объеденяет их, разделитель по умолчанию = ','</br>
* .toLocalString - элементы в строку и выводит её.</br>
* метод forEach() вызывает указанную функцию для каждого элемента в массиве; </br>
* метод map() возвращает массив, полученный в результате передачи всех элементов массива указанной функции; </br>
* метод filter() возвращает массив элементов, для которых заданная функция возвратила значение true.</br>











<h2> Объект Date </h2>
* Пример иниализации var now = new Date();</br>
* Номера месяцев начинаются с 0 </br>
* setFullYear(2017, 4, 22); // Присваиваем ему значение даты - 22 мая 2017
* toLocaleString() - Возвращает объект типа String содержащий дату в длинном формате
<script>
    var now = new Date();
    document.write("Сегодня: " + now.toLocaleString() + "</br>");
    //Пример как вывести посленее слово
    var s = "These are the times that try people's souls.";
    var last_word = s.substring(s.lastIndexOf(" ")+1, s.length);
    var myDate1 = new Date();  //Mon May 15 2017 19:20:25 GMT+0300 (RTZ 2 (зима))
    var myDate2 = new Date("December 14, 1975 12:10:00"); //Sun Dec 14 1975 12:10:00 GMT+0300 (RTZ 2 (зима))
    var myDate3 = new Date(1989, 6, 14);  //Fri Jul 14 1989 00:00:00 GMT+0400 (RTZ 2 (лето))
    var myDate4 = new Date(1998, 6, 14, 11, 20, 00); //Tue Jul 14 1998 11:20:00 GMT+0400 (RTZ 2 (лето))
    document.write(myDate1 + " </br>");
    document.write(myDate2+ " </br>");
    document.write(myDate3 + " </br>");
    document.write(myDate4 + " </br>");
    //alert(myDate1.getDate());
    myDate1.setDate(myDate1.getDate() + 10); // + 10 дней будет
   // alert(myDate1);
</script>






















<h2> Обертка </h2>
* Есть например баховый тип строка, а есть оберточный объект с методами, функциями и тд. Туда и обратно js автоматически переводит в нужных моментах.</br>
<h2> работа с данными (по значениею или по ссылке)</h2>
* При копировании создаётся копия значения и сохраняется в новой переменной</br>
* Когда функции передаётся переменная по значения - это означает, что функции передаётся копия, и любые изменеения не скажутся на изначальной переменной</br>
* В операциях присваивания по ссылке участвует сама ссылка, т.е</br>
* В сравнение ссылок: true, если ссылки идентичны, важны ссылки а не знаения, на которые они указывают</br>
* Остальное, как в c++</br>
<script>
    var printText = function(a) {document.write(a);}("Hello World! </br>");
    printText(); // Самовызываемая функция
</script>

<script>
    function my_function(n) {
        if (n == 0)
            return;
        my_function(n - 1);
        console.log(n + " ");
        return;
    }
    my_function(9);
</script>

<h2> Переменные и область видимости</h2>
* var - локальная переменная, просто "k = 3" - глобальная переменная
* ЛУчше всегжда объявлять переменные через var, чтобы например случайно не изменить глобальну/ переменную
<script>
    var scope = "глобальная";
    function f() {
        //alert(scope); // Показывает "undefined", а не "глобальная".
        var scope = "локальная"; // Переменная инициализируется здесь,
        // но определена она везде в функции.
        //alert(scope); // Показывает "локальная"
    }
    f();
</script>
<pre>var scope = "глобальная";</pre>
<pre>function f() {</pre>
<pre>   alert(scope); // Показывает "undefined", а не "глобальная".</pre>
<pre>   var scope = "локальная"; // Переменная инициализируется здесь,</pre>
<pre>   // но определена она везде в функции.</pre>
<pre>   alert(scope); // Показывает "локальная"</pre>
<pre>}</pre>
<h2> Сборка мусора </h2>
* Автоматическая сборка мусора
* Интерпритатор выясняет, к какому объекту больше нет возможности в будущем получить доступ и удаляет его.
*

<h2> Операторы </h2>
* -4.3 % 2.1 = -0.1 </br>
* === - опертор идентичности при сравнении, что-то сравниваетсяпо значению,что-то по ссылке. Числовые, строковые,логич по значению</br>
* d instanceof Date; // Равно true; объект d был создан с помощью конструктора Date</br>
typeof f == "function" // true </br>
f instanceof Function  // true</br>
f instanceof Object    // true</br>
*То есть true, на его конструкторы и на его надклассы</br>
*</br>
* Если строка сравнивается  с числом,то строка пытается преобразоваться в число</br>
* Логические && и || начинают вычесление с левого операнда</br>
* В сравнении строк, все прописные буквы идут раньше, чем строчные</br>
* Есть пораздрядные операторы, недумаю, что будут нужны</br>
* i = j = k = 0 работает,так как это читается справо налево</br>
* ?: -  единственный тернарный опертор</br>
* Результатом оператора typeof будет строка "number", "string" или "boolean", если</br>
  его операндом является число, строка или логическое значение</br>
* Для объектов, массивов и (как ни странно) значения null результатом будет</br>
  строка "object". Для операндовфункций результатом будет строка "function",</br>
  а для неопределенного операнда – строка "undefined".</br>
* Значение оператора typeof равно "object", когда операнд представляет собой объ</br>
  ектобертку Number, String или Boolean. Оно также равно "object" для объектовDate и RegExp.</br>
* Оператор delete выполняет попытку удалить свойство объекта, элемент массива или переменную, указанную в его операнде.</br>
* не могут быть удалены переменные, определенные пользователем с помощью инструкции var</br>
* delete влияет только на свойства:</br>
<pre>    var a = new Object();</pre>
<pre>    a.b = new Date();</pre>
<pre>    a.d = a.b;</pre>
<pre>    delete  a.b;</pre>
<pre>    alert(a.d);</pre>
* не надо пистаь так if(A || (i++)), так как если A = true, то до этого i не дайдёт.Нельзя возлогать роль не на первое выражение
<h2>Инструкции/конструкции</h2>
<pre>switch (a) {</pre>
<pre>   case 1:</pre>
<pre>       break;</pre>
<pre>   default:</pre>
* Просто интересный код:
<pre>switch(typeof x) {</pre>
<pre>case 'number':</pre>
* В case значениясравниваются на идентичность, то есть оператором ===
* В case тоже не надо ставить i++ или функции, ибо не факт, что до них дойдёт, не надо их подвергать ответственности
* for(инициализация, проверка, инкримент)
* Если проверка = true, то переходим к следующему шагу
* Можно так писать for(i = 0, j = 10; i < 10; i++, j)
* Не все свойства перечисляются, когда пользуешься for/in, много встроенного не выводится
* Любая инструкция может быть помечена указанным перед ней именем идентификатора и двоеточием:
* Имена меток отделены от имен переменных и функций
* идентификатор: инструкция
* break: имя_метки;
* Когда break используется с меткой, происходит переход в конец именованной инструкции или прекращение ее выполнения;
* continue запускает новую итерацию цикла.
* continue имя_метки; так тоже можно, например полезно, когда

<pre>outerloop:</pre>
<pre>for(var i = 0; i < 10; i++) {</pre>
<pre>   innerloop:</pre>
<pre>   for(var j = 0; j < 10; j++) {</pre>
<pre>       if (j > 3) break; // Выход из самого внутреннего цикла</pre>
<pre>       if (i == 2) break innerloop; // То же самое</pre>
<pre>       if (i == 4) break outerloop; // Выход из внешнего цикла</pre>
<pre>       document.write("i = " + i + " j = " + j + "<br>");</pre>
<pre>   }</pre>
<pre>}</pre>
<pre>document.write("FINAL i = " + i + " j = " + j + "<br>");</pre>

* continue как в форме без метки, так и с меткой может использоваться только в теле циклов while, do/while, for и for/in

* Тот факт, что функции определяются на этапе синтаксического анализа, а не во время исполнения, приводит к некоторым интересным эффектам.
Рассмотрим следующий фрагмент:
<pre>alert(f(4)); // Показывает 16. Функция f() может быть вызвана до того,</pre>
<pre>// как она определена.</pre>
<pre>var f = 0; // Эта инструкция переписывает содержимое свойства f.</pre>
<pre>function f(x) { // Эта "инструкция" определяет функцию f до того,</pre>
<pre>   return x*x; // как будут выполнены приведенные ранее строки.</pre>
<pre>}</pre>
<pre>alert(f); // Показывает 0. Функция f() перекрыта переменной f.</pre>
* Исключение Инструкция throw имеет следующий синтаксис: throw выражение;</br>
* Пример: if (x < 0) throw new Error("x не может быть отрицательным");</br>
* try/catch/finally</br>
* И блок catch, и блок finally не являются обязательными, однако после блока try должен обязательно присутствовать хотя бы один из них</br>
* Если есть catch, то сначала в него, потом в finally, если его нет, то сразу в finally</br>
* если в finally своё какое-то исключение, то оно заменяется предыдущим.</br>
* Если в finally есть return, то программа нормально завершается, и выходить из исключения, даже если оно не было обработано полностью</br>
* Инструкция with используется для временного изменения цепочки областей видимости.</br>
* with (объект)</br>
    инструкция</br>
* Если надо несколько раз обратиться так: frames[1].document.forms[0].address.value</br>
* <pre>with(frames[1].document.forms[0]) {</pre>
<pre>   // Здесь обращаемся к элементам формы непосредственно, например:</pre>
<pre>   name.value = "";</pre>
<pre>   address.value = "";</pre>
<pre>   email.value = "";</pre>
<pre>}</pre>
* Пустая инструкция</br>
* Если писать пустые инструкции, то лучше так</br>
* for(i=0; i < a.length; a[i++] = 0) /* Пустое тело цикла */;</br>
* </br>

<h2>Классы, конструкторы, прототипы</h2>
* Создат свой конструктор можно так: function LocalConstructor(){this.a = .., this. .. } </br>
* все объекты в JavaScript содержат внутреннюю ссылку на объект, известный как прототип. Любые свойства прототипа</br>
* становятся свойствами другого объекта, для которого он является прототипом. То есть, говоря другими словами,</br>
* любой объект в JavaScript наследует свойства своего прототипа</br>
<script>
    function Rectangle(w, h) {
        this.width = w;
        this.height = h;
    }
    // Прототип объекта содержит методы и другие свойства, которые должны
    // совместно использоваться всеми экземплярами этого класса.
    Rectangle.prototype.area = function() { return this.width * this.height; };
    var myRectangle1 = new Rectangle(2, 3);
    //alert(myRectangle1.area()); //6
</script>
* Вопервых, использование объ ектовпрототипов может в значительной степени уменьшить объем памяти, требуемый</br>
  для каждого объекта, т. к. объекты могут наследовать многие из своих свойств. Вовторых, объект наследует свойства,</br>
  даже если они были добавлены в прототип после создания объекта. Это означает наличие возможности добавлять новые</br>
  методы к существующим классам (хотя это не совсем правильно).</br>
* Унаследованные от прототипа метода ищутся в for/in спокойно</br>
* Как отлечить унаследованнные или нет</br>
<pre>var r = new Rectangle(2, 3);</pre>
<pre>r.hasOwnProperty("width"); // true: width – непосредственное свойство "r"</pre>
<pre>r.hasOwnProperty("area"); // false: area – унаследованное свойство "r"</pre>
<pre>"area" in r; // true: area – свойство объекта "r"</pre>
* Когда вы читаете свойство p объекта o, JavaScript сначала проверяет, есть ли у объекта o свойство с именем p. Если</br>
  такого свойства нет, то проверяется, есть ли свойство с именем p в объектепрототипе.</br>
* Если в прототипе было свойство p, и его установить в объекте с этим прототипом, то оно просто поменяется у объекта</br>
* В Java обычная практика программирования заключается в присвоении клас сам имен с первой прописной буквой, а объектам – со всеми строчными.</br>
* О разделении понятийкласса и экземпляра</br>
<pre>// Начнем с конструктора.</pre>
<pre>function Circle(radius) {</pre>
<pre>   // r – свойство экземпляра, оно определяется</pre>
<pre>   // и инициализируется конструктором.</pre>
<pre>   this.r = radius;</pre>
<pre>}</pre>
<pre>// Circle.PI – свойство класса, т. е. свойство функцииконструктора.</pre>
<pre>Circle.PI = 3.14159;</pre>
<pre>// Метод экземпляра, который рассчитывает площадь круга.</pre>
<pre>Circle.prototype.area = function( ) { return Circle.PI * this.r * this.r; }</pre>
<pre>// Метод класса – принимает два объекта Circle и возвращает объект с большим радиусом.</pre>
<pre>Circle.max = function(a,b) {</pre>
<pre>   176 Глава 9. Классы, конструкторы и прототипы</pre>
<pre>   if (a.r > b.r)return a;</pre>
<pre>   else return b;</pre>
<pre>}</pre>
*</br>
* О доступе данных, как инкапсуляции.</br>
<pre>function ImmutableRectangle(w, h) {</pre>
<pre>   // Этот конструктор не создает свойства объекта, где может храниться</pre>
<pre>   // ширина и высота. Он просто определяет в объекте методы доступа</pre>
<pre>   // Эти методы являются замыканиями и хранят значения ширины и высоты</pre>
<pre>   // в своих цепочках областей видимости.</pre>
<pre>   this.getWidth = function() { return w; }</pre>
<pre>   this.getHeight = function() { return h; }</pre>
<pre>}</pre>
<pre>// Обратите внимание: класс может иметь обычные методы в объектепрототипе.</pre>
<pre>ImmutableRectangle.prototype.area = function( ) {</pre>
<pre>   return this.getWidth( ) * this.getHeight( );</pre>
<pre>};</pre>
* </br>
* определяя класс, необходимо определить для него специальный метод toString(), чтобы экземпляры класса могли быть преобразованы в осмысленные строки.</br>
* Иногда можно определить класс, имеющий какойто разумный элементарный эквивалент. В этом случае может потребоваться определить для этого класса</br>
специальный метод valueOf().</br>
* Иногда, еслиоперделеены методы to String и valueOf, второй может выполниться первым, и преобразовать в число, а не в специальную строку</br>
* Чтобы иметь возможность сравнивать экземпляры класса, можно определить метод экземпляра с именем equals(). Этот метод</br>
должен принимать единственный аргумент и возвращать true, если аргумент эквивалентен объекту.</br>
* Для сравнения определяется метод compareTo(), как метод</br>
* a < b => compareTo() return < 0</br>
* a == b.. 0</br>
* a != b.. !0</br>
* Например сортировка массива complexNumbers.sort(new function(a,b) { return a.compareTo(b); });</br>
* Если переопределяем метод подкласса, то у его надкласса должен быть этот метод у прототипа. И у нынешнего берём протатим, и там определячем этот метод</br>
* Классы, разрабатываемые специально с целью заим ствования, называются классами'смесями, или просто смесями.</br>
* Такие классы заимствуют друг у друга методы, которые могут им быть полезны</br>
* Object.prototype.toString.apply(o); - Вызов базового toString</br>
*</br>
*</br>
* Грубое определение типа - это, если одинаковые методы => значит одного типа</br>
* Способы грубого определения типа:</br>
* 1)В действительности грубое определение типа должно работать более гибко: объект o должен рассматриваться как экземпляр</br>
класса c, если содержит методы, напоминающие методы класса c. В JavaScript «напоминающие» означает «имеющие те же самые</br>
имена» и (возможно) «объявленные с тем же количеством аргументов».</br>
* 2)Проверка факта заимсвования объектом методов данного класса</br>
* </br>
<h2> Создание модулей и пространства имён </h2>
* Для переносимых модулей многократного использования - без глобальных переменных надо жить лучше всего</br>
* Основная цель этой концепции – предотвратить конфликты имен, которые могут возникнуть при одновременном использовании</br>
* двух модулей, объявляющих глобальные свойства с одинаковыми именами: один модуль может перекрыть свойства другого,</br>
* что может привести к нарушениям в работе последнего.</br>
* Решение проблемы заключается в создании специально для данного модуля пространства имен и определении всех свойств и</br>
* методов внутри этого пространства.</br>
*
<pre>// Создать пустой объект, который будет выполнять функции пространства имен</pre>
<pre>// Это единственное глобальное имя будет вмещать все остальные имена</pre>
<pre>var Class = {};</pre>
<pre>// Определить функции в пространстве имен</pre>
<pre>Class.define = function(data) { /* здесь находится реализация метода */ }</pre>
<pre>Class.provides = function(o, c) { /* здесь находится реализация метода */ }</pre>
*
* .1. первое правило разработки JavaScriptмодулей: модуль никогда не должен выставлять больше одного имени в глобальном</br>
пространстве имен.</br>
* Два дополнения:</br>
* Если модуль добавляет имя в глобальное пространство имен, документация к модулю должна четко и ясно отражать</br>
назначение этого имени.</br>
* Если модуль добавляет имя в глобальное пространство имен, это имя должно быть однозначно связано с именем файла, из</br>
которого загружен модуль.</br>
* Если есть 2 модуля с одинаковым названием Class, то надо поместить их в отедльные подкаталоги, например</br>
 utilities/Class.js и flanagan/Class.js</br>
* И далее их имена уже не будет класса, а будут содеражть имена каталогов, то есть</br>
*
<pre>/**</pre>
<pre>* flanagan/Class.js: Модуль вспомогательных функций для работы с классами.</pre>
<pre>*</pre>
<pre>* Данный модуль определяет единственное глобальное имя "flanagan",</pre>
<pre>* если оно еще не существует. Затем создается объект пространства имен,</pre>
<pre>* который сохраняется в свойстве Class объекта flanagan. Все вспомогательные</pre>
<pre>* функции размещаются в пространстве имен flanagan.Class.</pre>
<pre>**/</pre>
<pre>var flanagan; // Объявление единственного глобального имени "flanagan"</pre>
<pre>if (!flanagan) flanagan = {}; // Создается объект, если он еще не определен</pre>
<pre>flanagan.Class = {} // Создается пространство имен flanagan.Class</pre>
<pre>// Теперь пространство имен заполняется вспомогательными методами</pre>
<pre>flanagan.Class.define = function(data) { /* реализация метода */ };</pre>
<pre>flanagan.Class.provides = function(o, c) { /* реализация метода */ };</pre>
*
* можно попробовать следовать соглашению языка про граммирования Java, согласно которому для придания уникальности именам</br>
пакетов нужно использовать префиксы, начинающиеся с имени вашего домена в Интернете. При этом порядок следования имен</br>
доменов следует менять на обратный, чтобы имя домена верхнего уровня (.com или нечто подобное) стояло первым, и указывать</br>
получившееся имя в качестве префикса для всех ваших JavaScript модулей. Поскольку мой сайт называется davidflanagan.com,</br>
я должен буду сохранить свои модули в файле с именем com/davidflanagan/Class.js и использовать пространство имен</br>
com.davidflanagan.Class</br>
* Пример моздания пространства имён и сразу проверка на то, что это можно делать</br>
*
<pre>// Создать глобальный символ "com", если его еще не существует</pre>
<pre>// Генерировать исключение, если он существует, но не является объектом</pre>
<pre>var com;</pre>
<pre>if (!com) com = {};</pre>
<pre>else if (typeof com != "object")</pre>
<pre>throw new Error("имя com существует, но не является объектом");</pre>
<pre>// Повторить процедуру создания и проверки типов на более низких уровнях</pre>
<pre>if (!com.davidflanagan) com.davidflanagan = {}</pre>
<pre>else if (typeof com.davidflanagan != "object")</pre>
<pre>throw new Error("com.davidflanagan существует, но не является объектом");</pre>
<pre>// Генерировать исключение, если com.davidflanagan.Class уже существует</pre>
<pre>if (com.davidflanagan.Class)</pre>
<pre>throw new Error("com.davidflanagan.Class уже существует");</pre>
<pre>// В противном случае создать и заполнить пространство имен</pre>
<pre>// с помощью одного большого литерала объекта</pre>
<pre>202 Глава 10. Модули и пространства имен</pre>
<pre>com.davidflanagan.Class = {</pre>
<pre>define: function(data) { /* здесь находится реализация функции */ },</pre>
<pre>provides: function(o, c) { /* здесь находится реализация функции */ }</pre>
<pre>};</pre>
*</br>
* Проверка доступности модуля, особенность в том, что com заранее объявляется
<pre>var com; // Перед проведением проверки объявляется глобальный символ</pre>
<pre>if (!com || !com.davidflanagan || !com.davidflanagan.Class)</pre>
*</br>
* Существует парадигма, говорящаю о том, что должен быть ненавязчивый js код. И в html докуменете его вообще не должно</br>
быть. Необходимо средство, с помощью котрого модули будут сами вызываться в нужный момент.</br>
* Если есть такое пространство  com.davidflanagan.Class.define, то чтобы не писать каждый раз много текста для обращения</br>
лучше в глобальном пространстве, если есть возможность сделать так</br>
<pre>// Создать простое пространство имен. При этом нет необходимости выполнять проверку</pre>
<pre>// на наличие ошибок, т. к. пользователь знает, какие символы существуют, а какие нет.</pre>
<pre>var Class = {};</pre>
<pre>// Импортировать символ в новое пространство имен.</pre>
<pre>Class.define = com.davidflanagan.Class.define;</pre>
* С перпеменная элементарных типов, то есть не ссылочнами штуками(объекты, массивы ...) Такой подход работать не будет</br>
* Нужены именно ссылки</br>
* Или уже так</br>
<pre>// Свойство элементарного типа, оно не должно импортироваться</pre>
<pre>com.davidflanagan.Class.counter = 0;</pre>
<pre>// Это метод доступа, который можно импортировать</pre>
<pre>com.davidflanagan.Class.getCounter = function() {</pre>
<pre>   return com.davidflanagan.Class.counter;</pre>
<pre>}</pre>
*</br>
* Разработчики модулей всегда должны указывать полные имена своих символов. Следование этому правилу можно наблюдать</br>
в только что продемонстрированном методе getCounter().</br>
*</br>
* Бывает, что внутри модуля ес тьпеременные или функции, для внутреннего использования, то есть для работы модулы, но также</br>
здесь нет чего, с помощью чего можно ограничить к ним доступ, это всё делается в документации. Очеь подробно.</br>
* Можно частные свойства обозначить с помощью '_' : _counter</br>
* </br>
* Замыкание – это функция вместе с областью видимости, которая действовала на момент определения функции.</br>
*</br>
*</br>
*</br>
* Существует модуль, содержащий функции для работы с модулями Module</br>
* .createNamespace: "Module.createNamespace("com.davidflanagan.Class");" создание пространства имён модуля</br>
* .require("name", version), требует, чтобы уже существовал модуль name с версией version, иначе выдаёт исключение</br>
* .importSymbols(name) импортирует символы в глобальное пространсво имён, например, если написать (Module), то importSymbols</br>
можно будет пользовать не как меотдом Module, а просто так.</br>
* .registerInitializationFunction() регистрирует функцию инициализации модуля, эта функция, которая запустится, когда весь</br>
документ загрузится, в ней как бы лежит начало работы модуля</br>
* .runInitializationFunctions(). - прямой её запуск</br>
*
<h2>Регулярное выражение</h2>
* В JavaScript регулярные выражения представлены объектами RegExp</br>
* Инициализация:</br>
<pre>var pattern = /s$/;</pre>
<pre>var pattern = new RegExp("s$");</pre>
* $ - конец строки, /s$/ - должно оканчиваться на s</br>
* Цифры и буквы обозначают сами себя</br>
* \0 Символ NUL (\u0000)</br>
* \t Табуляция (\u0009)</br>
* \n Перевод строки (\u000A)</br>
* \v Вертикальная табуляция (\u000B)</br>
* \f Перевод страницы (\u000C)</br>
* \r Возврат каретки (\u000D)</br>
* \xnn Символ из набора Latin, задаваемый шестнадцатеричным числом nn; например, \x0A – это то же самое, что \n</br>
* \uxxxx Unicodeсимвол, заданный шестнадцатеричным числом xxxx; например, \u0009 – это то же самое, что \t</br>
* \cX Управляющий символ ^X; например, \cJ эквивалентно символу перевода строки \n</br>
* ^ $ . * + ? = ! : | \ / ( ) [ ] { }</br>
* Для включение этих симмволов еужен символ обратного слэша</br>
* Символы повторения:</br>
* {n,m} Соответствует предшествующему шаблону, повторенному не менее n, но не более m раз</br>
* {n,} Соответствует предшествующему шаблону, повторенному n или более раз</br>
* {n} Соответствует в точности n экземплярам предшествующего шаблона</br>
* ? Соответствует нулю или одному экземпляру предшествующего шаблона; предшествующий шаблон является необязательным. Эквивалентно {0,1}</br>
* + Соответствует одному или более экземпляру предшествующего шаблона. Эквивалентно {1,}</br>
* * Соответствует нулю или более экземплярам предшествующего шаблона.a Эквивалентно {0,}</br>
*</br>
* Жадное повторение:  /a+/ - 1 или более букв a, для строки aaa - это aaa, а не жадное /a+?/ для строки aaa - это просто a.</br>
* Но не жадное повторение совсем не всегда работает</br>
* | - разделение альтернатив, /ab|cd|ef/ - или ab или cd, или ef</br>
* Альтернативы обраьатываются слева направо, и если одна найдена, то дальше ничего искаться не будет</br>
* Круглые скобки для разграничения и для создания подшаблонов шаблонов.</br>
* Можно делать ссылку назад к подвыражению из предыдущей части того же регулярного выражения. Это достигается путем</br>
указания одной или нескольких цифр после символа \, Например \1 ссылается на первое подвыражение, а \3 – на третье</br>
* Например, в следующем регулярном выражении ссылка на вложенное подвыражение ([Ss]cript) будет выглядеть как \2:</br>
* /['"][^'"]*['"]/ <=> /(['"])[^'"]*\1/</br>
* /([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/ Здесь \2 - это скобки  с fun, ибо (?...) - это только группипрвка</br>
* | Альтернативы. Соответствует либо подвыражению слева, либо подвыражению справа.</br>
* (...) Группировка. Группирует элементы в единое целое, которое может использоваться с символами *, +, ?, | и т. п.</br>
Также запоминает символы, соответствующие этой группе, для использования в последующих ссылках.</br>
* (?:...) Только группировка. Группирует элементы в единое целое, но не запоми нает символы, соответствующие этой группе.</br>
* \n Соответствует тем же символам, которые были найдены при первом соответствии группе с номером n. Группы – это подвыражения</br>
внутри скобок (возможно, вложенных). Номера группам присваиваются путем подсчета левых скобок слева направо. Группы,</br>
сформированные с помощью символов (?:, не нумеруются.</br>
* Есть элементы регулярного выражения не несущие в себе символы, а лишь условия на позиции, они называются якорными</br>
* Например /^JavaScript$/ - JavaScript на отдельаной строке</br>
* /\bJava\b/ Найти отдельное слово, \b - якоря - границы слова</br>
* Если поместить выражение между символами (?= и ), оно станет условием на последующие символы, требующим, чтобы эти символы</br>
соответствовали указанному шаблону, но не включались в строку соответствия</br>
*  /[Jj]ava([Ss]cript)?(?=\:)/ - Ищет JavaScript или Java за которыми есть двоеточие</br>
* ?! это отрицательное условие на последующие символы</br>
<p><img src="media/Рег%20Выраж%20Якорные%20символы.png" width="800" height="430"></p>
* Флаг i указывает, что поиск по шаблону должен быть нечувстви тельным к регистру символов, а флаг g – что поиск должен</br>
быть глобальным, т. е. должны быть найдены все соответствия в строке. /../gi или /../i или /../g</br>
<p><img src="media/Рег%20Выраж%20Якорные%20символы.png" width="800" height="400"></p>
<h3>Методы класса string</h3>
* Существует 4 метода</br>
* .search(/../) - Не поддерживает глобальный поиск, если аргумент строка, то сам преобразует её</br>
* .replace(/../, "..") - находит и заменяет. Если первый аргумент строка, то делает буквальный поиск, не конвертируюя её.</br>
* Важный пример</br>
<pre>// Цитата – это кавычка, за которой следует любое число символов,</pre>
<pre>// отличных от кавычек (их мы запоминаем), за этими символами следует</pre>
<pre>// еще одна кавычка.</pre>
<pre>var quote = /"([^"]*)"/g;</pre>
<pre>// Заменяем прямые кавычки типографскими и оставляем без</pre>
<pre>// изменений содержимое цитаты, хранящееся в $1.</pre>
<pre>text.replace(quote, "``$1''");</pre>
* .match() принимает в качестве единственного аргумента регулярное выражение (или преобразует свой аргумент в регулярное</br>
выражение, передав его конструктору RegExp()) и возвращает массив, содержащий результа ты поиска. Если в регулярном выражении</br>
установлен флаг g, метод возвращает массив всех соответствий, присутствующих в строке. Например:</br>
<pre>   "1 плюс 2 равно 3".match(/\d+/g) // возвращает ["1", "2", "3"] </pre>
* Важный пример о том, как работает match и скобки</br>
<pre>var url = /(\w+):\/\/([\w.]+)\/(\S*)/; // Ищет адрес, с сохранением элементов из него, что в скобках</pre>
<pre>var text = "Посетите мою домашнюю страницу http://www.isp.com/~david";</pre>
<pre>var result = text.match(url);</pre>
<pre>if (result != null) {</pre>
<pre>   var fullurl = result[0]; // Содержит "http://www.isp.com/~david"</pre>
<pre>   var protocol = result[1]; // Содержит "http"</pre>
<pre>   var host = result[2]; // Содержит "www.isp.com"</pre>
<pre>   var path = result[3]; // Содержит "~david" </pre>
<pre>}</pre>
* Есть свойство length:</br>
* Однако когда match() вызывается с регулярным выражением без флага g, возвращаемый массив имеет еще два свойства: index,</br>
содержащее номер позиции символа внутри строки, с которого начинается соответствие, и input, являющееся копией строки, в</br>
которой выполнялся поиск</br>
* .split(/../ или "") разбивает на массив подстрок</br>
* В конструкторе RegExp 1 аргумент - регулярное выражение, второй(необязательный) - m,i,g</br>
* У RegExp есть как локальные свойсва у экземпляров, так и глобальные у объекта RegExp</br>
* .exec() исполняет регулярное выражение для указанной строки, т. е. ищет в строке соответствие. Если соответствие не</br>
найдено, метод возвращает null. ОДнако, если что-то найдено, то возвращет такой же массив, как и match без флага g</br>
* exec возвращает одно совпадение, переменную lastIndex, следующего непосредственно за найденной подстрокой</br>
* Когда метод exec() вызывается для того же регулярного выражения второй раз, он начинает поиск с символа, позиция</br>
которого указана в свойстве lastIndex. Если exec() не находит соответствия, свойство lastIndex равно 0</br>
<script>
    var pattern = /Java/g;
    var text = "JavaScript – это более забавная штука, чем Java!";
    var result;
    while((result = pattern.exec(text)) != null) {
        /*alert("Найдено `" + result[0] + "'" +
            " в позиции " + result.index +
            "; следующий поиск начинается с " + pattern.lastIndex);*/
    }
</script>
*</br>
* Ещё один метод - test();Он принимает строку и возвращает true, если строка соответствует регулярному выражению:</br>
* Тоже самое делает со свойством lastIndex</br>
* ВАЖНО</br>
* Надо следить за тем, чтобы lastIndex после осмотра строки был равным нулю, иначе при работе со следующей могут быть проблемы</br>
* Каждый объект REgExp имеет 5 свойств.</br>
* .source - текст регулярного соответсвия, только для четния доступно</br>
* .global – это доступное только для чтения логическое значение, имеется ли в регулярном выражении флаг g</br>
* .ignoreCase – это доступное только для чтения логическое значение, определяющее, имеется ли в регулярном выражении флаг i</br>
* .multiline – это доступное только для чтения логическое значение, определяющее, имеется ли в регулярном выражении флаг m.</br>
* .lastIndex - последее свойство, которое возвращает последний индекс, с которого продолжится поиск. </br>

<h1> JavaScript в вебброузерах </h1>
* В клиентском языке JavaScript объект Document представляет HTMLдокумент, а объект Window – окно (или отдельный фрейм),</br>
в котором отображается этот до кумент</br>
* Window представляет собой глобадьный объект при программированиии со стороны клиента.</br>
* Имеет свои свойства и методы. '.document' ссылается на Document</br>
* Свойства и методы Window позволяют манипулировать окном веб-броузера</br>
* window, self - две ссылки на себя(на объект Window)</br>
* Так как window - глобальный объект, то var answer = 42; window.answer = 42; совершено одинаковые вещи в контексте браузера</br>
* Каждое окно приложения имеет уникальный объект Window и определяет уникальный контекст исполнения для кода клиентского</br>
JavaScript. Другими словами, глобальная переменная, объявленная JavaScript кодом в одном окне, не является глобальной в другом окне.</br>
* '.location', ссылающееся на связанный с окном объект Location</br>
* '.frames[]' ссылающийся на объекты Window, представляющие фреймы исходного окна</br>
* frames[1].document ссылается на объект Document второго дочернего фрейма текущего окна, а просто document на текущее окно</br>
* В каждом объекте Document имеется массив forms[], содержащий объекты Form, которые представляют любые присутствующие в документе HTMLформы</br>
* В каждом объекте Form имеется массив elements[], содержащий объекты, которые представляют различные элементы HTMLформ (поля ввода, кнопки и т. д.)</br>
* Т.е сущестувет иерархия в корне которой объект window</br>
<p><img src="media/Иерархия%20объектов%20броузера%20.png" width="994" height="816"></p>
* На картинце многие объекты происходят из объекта Document. Это поддерево большой иерархии на стороне клиента известно как</br>
объектная модель документа (Document Object Model, DOM), на нём сконцентрирована вся стандартизация*</br>
* На рисунке объекты документа, которые стали стандартом "де-факто", и называются нулевой уровень модели DOM</br>
*</br>
* js - управляемая событиямми модель программирования</br>
*</br>
* ненавязчивый JavaScript'код - т.е не доожен привлекать внимание, должен помогать</br>
* Основная суть хранить далеко от html и css, то есть просто отдельно</br>
* js код нужно делать максимально модульным, для возможности подключения большего числа библиотек и меньшего числа проблем</br>
* Важно, что всё должно работать и без js, то есть например при его отключении доожны просто пропадать эффекты на кнопках или что-то такое.</br>
* Называется это feature testing</br>
* Js не должен делать страницу менее доступной, только более доступной.</br>
*
</body>
</html>